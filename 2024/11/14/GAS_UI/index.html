<html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Try to save my life"><meta name="keyword"><title>GAS UI信息同步
-
小禾苗の垃圾堆
-

</title><link rel="icon" href="/img/favicon.ico">
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/helpers.css">

<script src="/js/clipboard/clipboard.min.js"></script>


<script src="/js/bootstrap.js"></script>

<script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!-- hexo injector head_end start --><style>
body hanla:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hanla,
html pre hanla,
html kbd hanla,
html samp hanla,
html ruby hanla,
html .tag-list-item hanla {
    display: none;
}

html ol > hanla,
html ul > hanla {
    display: none;
}
</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading-wrapper" data-loading="data-loading"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="data-filter"><div class="head" data-show="data-show"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/">小禾苗の垃圾堆</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle" title="菜单按钮"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><span>搜索</span>
<i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/about">关于</a></div></div></header>
<div class="menubar-head" id="menubar"><ul class="menubar-ul"><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><i class="icon icon-archive"></i>
<a class="menubar-link" href="/archives">Archives</a></li><li class="menubar-item"><i class="icon icon-tags"></i>
<a class="menubar-link" href="/tags">Tags</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><a class="menubar-link" href="/about"><span><hanla></hanla>关于</span></a></li></ul><div class="menu-search-box search-button"><div>搜索</div>
<i class="icon icon-search"></i></div></div></div><div class="main" data-page="post"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/2024/11/14/GAS_UI/">GAS UI<hanla></hanla>信息同步<hanla></hanla></a></h1></header><div class="post-meta"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2024-11-14 23:02:54" datetime="2024-11-14T15:02:54.000Z">2024-11-14</time></div>|
<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GAS/" rel="tag">GAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/" rel="tag">UI</a></li></ul></div>
<div class="post-visit"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>访问</span></div></div><div class="post-info"><div class="post-word-count">本文共<hanla></hanla>4,642<hanla></hanla>字。</div>
</div><div class="article-entry" itemprop="articleBody"><h3 id="UI-设计"><a href="#UI-设计" class="headerlink" title="UI 设计"></a>UI 设计<hanla></hanla></h3><p>UI 的作用是向用户展示其可以直接查看到的页面，通过直观的形式显示角色的各种信息，最经典的一种结构就是 MVC。</p>
<ol>
<li>Model 层：处理数据相关的内容，包括数据库读写、更新、删除等操作，并且定义了操作和访问这些数据的方法</li>
<li>View 层：展示 Model 层的数据给用户，并且接收用户的输入。</li>
<li>Controller 层：接收用户的输入，并根据输入调度和处理请求。他负责处理用户与应用程序的交互逻辑，决定如何更新 Model 层数据和选择合适的 View 层。</li>
</ol>
<h3 id="UI-属性绑定"><a href="#UI-属性绑定" class="headerlink" title="UI 属性绑定"></a>UI 属性绑定</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>通过 C++<hanla></hanla>创建 GameplayTags（可以在 C++<hanla></hanla>和蓝图中同时获取到 tag）</li>
<li>创建一个 DataAsset 类，设置 tag 对应的属性和显示内容</li>
<li>创建<hanla></hanla><code>AttritbueMenuWidgetController</code><hanla></hanla>实现对应的逻辑</li>
</ol>
<h4 id="旧版配置委托的实现"><a href="#旧版配置委托的实现" class="headerlink" title="旧版配置委托的实现"></a>旧版配置委托的实现<hanla></hanla></h4><p>OverlayWidget 作为整体的展示页面，展示血条和蓝条，配套的是 OverlayWidgetController</p>
<img src="/2024/11/14/GAS_UI/1.PNG" class="" title="img">

<p>在其中实现定义委托</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnAttributeChangedSignature, <span class="type">float</span>, NewAttribute);</span><br></pre></td></tr></tbody></table></figure>

<p>在创建对应属性的委托</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BroadcastInitialValues</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BindCallbacksToDependencies</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">"GAS|Attributes"</span>)</span><br><span class="line">FOnAttributeChangedSignature OnHealthChanged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">"GAS|Attributes"</span>)</span><br><span class="line">FOnAttributeChangedSignature OnMaxHealthChanged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">"GAS|Attributes"</span>)</span><br><span class="line">FOnAttributeChangedSignature OnManaChanged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">"GAS|Attributes"</span>)</span><br><span class="line">FOnAttributeChangedSignature OnMaxManaChanged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">"GAS|Messages"</span>)</span><br><span class="line">FMessageWidgetRowSignature MessageWidgetRowDelegate;</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们使用 GAS 里自带的一个函数<hanla></hanla><code>GetGameplayAttributeValueChangeDelegate</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FOnGameplayAttributeValueChange, <span class="type">const</span> FOnAttributeChangeData&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Register for when an attribute value changes */</span></span><br><span class="line"><span class="function">FOnGameplayAttributeValueChange&amp; <span class="title">GetGameplayAttributeValueChangeDelegate</span><span class="params">(FGameplayAttribute Attribute)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>配置对应触发的回调</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddLambda</span>([<span class="keyword">this</span>](<span class="type">const</span> FOnAttributeChangeData&amp; Data){OnHealthChanged.<span class="built_in">Broadcast</span>(Data.NewValue);});</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetMaxHealthAttribute</span>()).<span class="built_in">AddLambda</span>([<span class="keyword">this</span>](<span class="type">const</span> FOnAttributeChangeData&amp; Data){OnMaxHealthChanged.<span class="built_in">Broadcast</span>(Data.NewValue);});</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetManaAttribute</span>()).<span class="built_in">AddLambda</span>([<span class="keyword">this</span>](<span class="type">const</span> FOnAttributeChangeData&amp; Data){OnManaChanged.<span class="built_in">Broadcast</span>(Data.NewValue);});</span><br><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetMaxManaAttribute</span>()).<span class="built_in">AddLambda</span>([<span class="keyword">this</span>](<span class="type">const</span> FOnAttributeChangeData&amp; Data){OnMaxManaChanged.<span class="built_in">Broadcast</span>(Data.NewValue);});</span><br></pre></td></tr></tbody></table></figure>

<p>上面是在传入的时候有绑定了一个 lamada 函数，从而在 Value Change 的时候触发我们自定义的委托</p>
<blockquote>
<p>[capture-list] (parameters) -&gt; return-type { body }</p>
<ul>
<li>capture-list: 捕获外部变量的列表，可以为空。</li>
<li>parameters: 函数参数列表，可以为空。</li>
<li>return-type: 返回类型，可以省略（编译器会自动推断）。</li>
<li>body: 函数体。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FOnGameplayAttributeValueChange&amp; <span class="title">UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate</span><span class="params">(FGameplayAttribute Attribute)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> ActiveGameplayEffects.<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Attribute);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找对应的属性委托，没有就添加<hanla></hanla></span></span><br><span class="line"><span class="function">FOnGameplayAttributeValueChange&amp; <span class="title">FActiveGameplayEffectsContainer::GetGameplayAttributeValueChangeDelegate</span><span class="params">(FGameplayAttribute Attribute)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> AttributeValueChangeDelegates.<span class="built_in">FindOrAdd</span>(Attribute);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储一些委托<hanla></hanla></span></span><br><span class="line">TMap&lt;FGameplayAttribute, FOnGameplayAttributeValueChange&gt; AttributeValueChangeDelegates;</span><br><span class="line"><span class="comment">// 又回到了这个委托定义<hanla></hanla></span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FOnGameplayAttributeValueChange, <span class="type">const</span> FOnAttributeChangeData&amp;);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="GameplayAttribute"><a href="#GameplayAttribute" class="headerlink" title="GameplayAttribute"></a>GameplayAttribute</h5><p><a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/en-us/unreal-engine/gameplay-attributes-and-attribute-sets-for-the-gameplay-ability-system-in-unreal-engine">https://dev.epicgames.com/documentation/en-us/unreal-engine/gameplay-attributes-and-attribute-sets-for-the-gameplay-ability-system-in-unreal-engine</a></p>
<blockquote>
<p><code>FGameplayAttribute</code>describes a FGameplayAttributeData or float property inside an attribute set. Using this provides editor UI and helper functions*</p>
</blockquote>
<p><code>Attribute</code> 是由 FGameplayAttributeData 定义的浮点值。 Attributes 能够表达从角色的生命值到角色等级到药瓶的价格等任何数值<hanla></hanla>*</p>
<h4 id="新版配置委托的实现"><a href="#新版配置委托的实现" class="headerlink" title="新版配置委托的实现"></a>新版配置委托的实现</h4><p>我们通过 ASC 去实现对属性的监听，然后再 Controller 里我们不再单独的广播一个属性，而是有属性修改的时候，委托就会触发，将变动的属性一并广播出去。</p>
<p>在 Widget 里，我们可以监听对应的属性变化，委托的广播，不仅仅可以传递数值，也可以传递结构体。</p>
<h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><ol>
<li>新建一个<hanla></hanla><code>AttributeMenuWidgetController</code><hanla></hanla>实现对 ASC 广播的监听</li>
<li>使用标签匹配的方式，实现对来自广播的数据的检索，知道去更新哪个属性（需要在 C++<hanla></hanla>和 UE 蓝图里都能获取）</li>
<li>创建数据列表，获取到匹配的标签后，拿到对应的数据提交给 widget</li>
<li>在 Widget 里，根据标签更新数据</li>
</ol>


<h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ol>
<li>WidgetController，绑定从 Ability System 广播来的委托，当 attribute 变化时，widgetcontroller 会知道<ol>
<li>Set up to receive broadcasts from the ability system when attributes change</li>
</ol>
</li>
<li>widgetcontroller 通过这个 attribute，找出对应的 gameplaytag<ol>
<li>Map attribute with gameplaytag</li>
<li>fidn a way to reference these gameplay tags(找到一种引用标签的方法)<ol>
<li><code>RequestGameplayTags(FName("xxx.xxx.xxx"))</code><hanla></hanla>可以向 gameplay tag manager 查找 tag</li>
<li>每次都手写 xxx.xxx.xxx 太容易出错，转而用单例管理</li>
</ol>
</li>
</ol>
</li>
<li>使用 gameplaytag，在 DataAsset(UAttributeInfo)<hanla></hanla>里查找对应的结构体内容<ol>
<li>DataAsset capable of receiving gameplay tags and returning our aura attribute info struct</li>
</ol>
</li>
<li>将找到的内容发送给 widget</li>
</ol>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ol>
<li><h6 id="配置-GameplayTags-单例"><a href="#配置-GameplayTags-单例" class="headerlink" title="配置 GameplayTags 单例"></a>配置 GameplayTags 单例</h6><ol>
<li><p>创建 C++<hanla></hanla>文件，继承自 None</p>
</li>
<li><p>创建一个结构体类，将其作为单例，头文件中我们添加一个静态<hanla></hanla><code>Get</code><hanla></hanla>函数，用于从类直接获取单例。然后创建一个<hanla></hanla><code>InitializeNativeGameplayTags()</code><hanla></hanla>初始化内部的<hanla></hanla><code>Tag</code><hanla></hanla>标签，最后创建一个静态属性<hanla></hanla><code>FMyGameplayTags</code><hanla></hanla>用来存储单例，<code>Get</code><hanla></hanla>返回的就是他</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"GameplayTagContainer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GameplayTags 标签 单例模式</span></span><br><span class="line"><span class="comment"> * 内部包含原生的项目中使用的标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FMyGameplayTags</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> FMyGameplayTags&amp; <span class="title">Get</span><span class="params">()</span> </span>{ <span class="keyword">return</span> GameplayTags; }</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitializeNativeGameplayTags</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        FGameplayTag Attributes_Primary_Strength;</span><br><span class="line"></span><br><span class="line">        FGameplayTag Attributes_Secondary_Armor;</span><br><span class="line"></span><br><span class="line">        FGameplayTag InputTag_LMB;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> FMyGameplayTags GameplayTags;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>先用<hanla></hanla><code>UGameplayTagsmanager::Get()</code><hanla></hanla>拿到游戏标签管理器的单例实例，然后添加一个原生的游戏标签。xxx.xxx.xxx 对应表情管理器的层级，然后我们创建的<hanla></hanla><code>FGameplayTag Attributes_Primary_Strength;</code>存储创建出来的<hanla></hanla><code>Gameplaytags</code>，便于日后使用</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"AuraGameplayTags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"GameplayTagsManager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create instance</span></span><br><span class="line">FAuraGameplayTags FAuraGameplayTags::GameplayTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When we create a gameplay tag, it's registered with the gameplay tag manager.</span></span><br><span class="line"><span class="comment">// This is an object in our project there's only one of them, and it manages the gameplay tags and we can also use it to add gameplay tags even natively here in C++.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FAuraGameplayTags::InitializeNativeGameplayTags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Primary Attributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate the tag with actual gameplay tag variable</span></span><br><span class="line">    GameplayTags.Attributes_Primary_Strength = UGameplayTagsManager::<span class="built_in">Get</span>().<span class="built_in">AddNativeGameplayTag</span>(</span><br><span class="line">       <span class="built_in">FName</span>(<span class="string">"Attributes.Primary.Strength"</span>),</span><br><span class="line">       <span class="built_in">FString</span>(<span class="string">"Increases physical damage"</span>)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Secondary Attributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    GameplayTags.Attributes_Secondary_Armor = UGameplayTagsManager::<span class="built_in">Get</span>().<span class="built_in">AddNativeGameplayTag</span>(</span><br><span class="line">       <span class="built_in">FName</span>(<span class="string">"Attributes.Secondary.Armor"</span>),</span><br><span class="line">       <span class="built_in">FString</span>(<span class="string">"Reduces damage taken, improves Block Chance"</span>)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Input Tags</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    GameplayTags.InputTag_LMB = UGameplayTagsManager::<span class="built_in">Get</span>().<span class="built_in">AddNativeGameplayTag</span>(</span><br><span class="line">       <span class="built_in">FName</span>(<span class="string">"InputTag.LMB"</span>),</span><br><span class="line">       <span class="built_in">FString</span>(<span class="string">"Input Tag for Left Mouse Button"</span>)</span><br><span class="line">       );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers the given name as a gameplay tag, and tracks that it is being directly referenced from code</span></span><br><span class="line"><span class="comment"> * This can only be called during engine initialization, the table needs to be locked down before replication</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param TagName The Name of the tag to add</span></span><br><span class="line"><span class="comment"> * @param TagDevComment The developer comment clarifying the usage of the tag</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Will return the corresponding FGameplayTag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">GAMEPLAYTAGS_API FGameplayTag <span class="title">AddNativeGameplayTag</span><span class="params">(FName TagName, <span class="type">const</span> FString&amp; TagDevComment = TEXT(<span class="string">"(Native)"</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>XXXGameplayTags 按照内容划分，应该归于资源类，那么应该放在什么时候初始化呢？考虑到这个原因，我们应该使用一个资源管理器，去统一的管理所有资源初始化、加载的逻辑（这里可以再去补充看一下 Lyra 的初始化链）</p>
<h6 id="实现资源管理器类"><a href="#实现资源管理器类" class="headerlink" title="实现资源管理器类"></a>实现资源管理器类</h6><ol>
<li><p>新建一个 C++<hanla></hanla>文件，继承自<hanla></hanla><code>AssetManager</code></p>
</li>
<li><p>新建一个 Get 获取单例和初始化函数<hanla></hanla></p>
 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AURA_API</span> UAuraAssetManager : <span class="keyword">public</span> UAssetManager</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> UAuraAssetManager&amp; <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartInitialLoading</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UAuraAssetManager&amp; <span class="title">UAuraAssetManager::Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 避免引擎还未完全初始化</span></span><br><span class="line">    <span class="built_in">check</span>(GEngine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们获取到的是引用<hanla></hanla>(&amp;)，所以返回时需要加上<hanla></hanla>*<hanla></hanla>来返回实例</span></span><br><span class="line">    UAuraAssetManager* AuraAssetManager = <span class="built_in">Cast</span>&lt;UAuraAssetManager&gt;(GEngine-&gt;AssetManager);</span><br><span class="line">    <span class="comment">// 解引用，直接返回操作的对象而不是副本</span></span><br><span class="line">    <span class="keyword">return</span> *AuraAssetManager;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖父类的<hanla></hanla>StartInitialLoading()，在内部添加对自定义标签的处理<hanla></hanla></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraAssetManager::StartInitialLoading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Super::<span class="built_in">StartInitialLoading</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize Native Gameplay Tags</span></span><br><span class="line">    FAuraGameplayTags::<span class="built_in">InitializeNativeGameplayTags</span>();</span><br><span class="line">    <span class="comment">// UAbilitySystemGlobals::Get().InitGlobalData(); // 不是这里的功能</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将引擎默认的资源管理器替换为我们自定义的资源管理器，在 Project Settings-&gt;General Settings-&gt;Default Classes-&gt;Advanced-&gt;Asset Manager Class 设置</p>
</li>
<li><p>打开 Project Settings-&gt;Project-&gt;GameplayTags-&gt;Manage Gameplay Tags 查看是否修改成功</p>
</li>
<li><p>测试 GameplayTags 是否生效</p>
<ol>
<li>看的测试用例是在 ASC 触发的<hanla></hanla><code>AbilityActorInfoSet()</code><hanla></hanla>中添加，实际上就是查了一下是否能够调用 GameplayTags 以及读取的内容是否准确</li>
</ol>
</li>
</ol>
<h4 id="存储-UI-所需要的数据"><a href="#存储-UI-所需要的数据" class="headerlink" title="存储 UI 所需要的数据"></a>存储 UI 所需要的数据</h4><blockquote>
<h5 id="为什么使用-DataAsset-而不是-DataTable？"><a href="#为什么使用-DataAsset-而不是-DataTable？" class="headerlink" title="为什么使用 DataAsset 而不是 DataTable？"></a>为什么使用 DataAsset 而不是 DataTable？</h5><ol>
<li>DataTable 主要用于存储和读取数据，一般我们给策划配表的 csv 文件，直接导入就是 DataTable。</li>
<li>DataAsset 则是一种将资源整合在一起的方式，用于实现资源管理。通过 DataAsset，可以将某个对象使用所有资源集中在一起，当需要加载该对象时，只需要加载对应的 DataAsset。</li>
<li>DataAsset 需要手动定义数据结构并添加引用的数据，且只存储引用并不加载。</li>
</ol>
</blockquote>
<p>我们通过代码去修改 DataAsset 里的属性显示的实际的值</p>
<h5 id="配置-DataAsset"><a href="#配置-DataAsset" class="headerlink" title="配置 DataAsset"></a>配置 DataAsset</h5><ol>
<li><p>创建一个类，继承自 DataAsset</p>
</li>
<li><p>创建 DataAsset 使用的结构体</p>
<ol>
<li><p><code>AttributeTag</code>，<code>AttributeName</code>，<code>AttributeDescription</code><hanla></hanla>是展示用的，不会实时修改，实际的属性数值<hanla></hanla><code>AttributeValue</code><hanla></hanla>我们会实时修改，所以添加的是<hanla></hanla><code>EditDefaultsOnly</code><hanla></hanla>属性</p>
</li>
<li><p><code>AttributeInformation</code><hanla></hanla>我们用来在面板里添加和配置数据</p>
</li>
<li><p><code>FindAttributeInfoForTag</code><hanla></hanla>实现通过<hanla></hanla><code>Gameplaytag</code><hanla></hanla>去获取<hanla></hanla><code>FAuraAttributeInfo</code><hanla></hanla>数据，最后我们要实现在 C++<hanla></hanla>侧修改数据，UI 侧获取数据</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FAuraAttributeInfo</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly)</span><br><span class="line">    FGameplayTag AttributeTag = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly)</span><br><span class="line">    FText AttributeName = <span class="built_in">FText</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly)</span><br><span class="line">    FText AttributeDescription = <span class="built_in">FText</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly)</span><br><span class="line">    <span class="type">float</span> AttributeValue = <span class="number">0.f</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AURA_API</span> UAttributeInfo : <span class="keyword">public</span> UDataAsset</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FAuraAttributeInfo <span class="title">FindAttributeInfoForTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag, <span class="type">bool</span> bLogNotFound = <span class="literal">false</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, meta = (TitleProperty = <span class="string">"AttributeName"</span>))</span><br><span class="line">    TArray&lt;FAuraAttributeInfo&gt; AttributeInformation;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FAuraAttributeInfo <span class="title">UAttributeInfo::FindAttributeInfoForTag</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag, <span class="type">bool</span> bLogNotFound)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 遍历配置的所有<hanla></hanla>FAuraAttributeInfo</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FAuraAttributeInfo&amp; Info : AttributeInformation)</span><br><span class="line">    {</span><br><span class="line">       <span class="comment">// 如果有匹配的就返回结构体</span></span><br><span class="line">      <span class="keyword">if</span> (Info.AttributeTag.<span class="built_in">MatchesTagExact</span>(AttributeTag))</span><br><span class="line">      {</span><br><span class="line">         <span class="keyword">return</span> Info;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bLogNotFound)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">"Can't find Info for AttributeTag [%s] on AttributeInfo [%s]."</span>), *AttributeTag.<span class="built_in">ToString</span>(), *<span class="built_in">GetNameSafe</span>(<span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FAuraAttributeInfo</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p>创建 DataAsset，继承自我们创建的 UAttributeInfo 类，添加所需要的内容</p>
</li>
</ol>
<h4 id="将数据同步到-UI-上"><a href="#将数据同步到-UI-上" class="headerlink" title="将数据同步到 UI 上"></a>将数据同步到 UI 上</h4><blockquote>
<p>实现 UI 侧订阅数据，C++<hanla></hanla>侧更新数据</p>
</blockquote>
<ol>
<li><h5 id="配置AttributeMenuWidgetController"><a href="#配置AttributeMenuWidgetController" class="headerlink" title="配置AttributeMenuWidgetController"></a><code>配置<hanla></hanla>AttributeMenuWidgetController</code></h5><ol>
<li>覆盖一下父类的初始化属性函数和构建委托的函数，我们后续在这两个函数里实现对属性面板的广播</li>
<li><code>AttributeInfoDelegate</code><hanla></hanla>设置了<hanla></hanla><code>BlueprintAssignable</code><hanla></hanla>修饰符，可以在蓝图里作为回调绑定使用</li>
<li><code>AttributeInfo</code><hanla></hanla>使用<hanla></hanla><code>EditDefaultsOnly</code>，只能在 UE 面板上编辑</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(BlueprintType, Blueprintable)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AURA_API</span> UAttributeMenuWidgetController : <span class="keyword">public</span> UAuraWidgetController</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BindCallbacksToDependencies</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BroadcastInitialValues</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">"GAS|Attributes"</span>)</span><br><span class="line">    FAttributeInfoSignature AttributeInfoDelegate;,</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">    TObjectPtr&lt;UAttributeInfo&gt; AttributeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BroadcastAttributeInfo</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag, <span class="type">const</span> FGameplayAttribute&amp; Attribute)</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    UAuraAttributeSet* AS = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    <span class="built_in">check</span>(AttributeInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : AS-&gt;TagsToAttributes)</span><br><span class="line">    {</span><br><span class="line">       <span class="comment">// Whatever we bind to this delegate needs the correct signature, the signature we need have to take a const reference to FOnAttributeChangeData</span></span><br><span class="line">       AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Pair.<span class="built_in">Value</span>()).<span class="built_in">AddLambda</span>(</span><br><span class="line">          [<span class="keyword">this</span>, Pair](<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span><br><span class="line">          {</span><br><span class="line">             <span class="built_in">BroadcastAttributeInfo</span>(Pair.Key, Pair.<span class="built_in">Value</span>());</span><br><span class="line">          }</span><br><span class="line">       );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    UAuraAttributeSet* AS = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    <span class="built_in">check</span>(AttributeInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : AS-&gt;TagsToAttributes)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">BroadcastAttributeInfo</span>(Pair.Key, Pair.<span class="built_in">Value</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastAttributeInfo</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FGameplayAttribute&amp; Attribute)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    FAuraAttributeInfo Info = AttributeInfo-&gt;<span class="built_in">FindAttributeInfoForTag</span>(AttributeTag);</span><br><span class="line">    Info.AttributeValue = Attribute.<span class="built_in">GetNumericValue</span>(AttributeSet);</span><br><span class="line">    AttributeInfoDelegate.<span class="built_in">Broadcast</span>(Info);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h5 id="配置-HUD-类"><a href="#配置-HUD-类" class="headerlink" title="配置 HUD 类"></a>配置 HUD 类</h5><ol>
<li><p>HUD 类中，我们原先配置了创建<hanla></hanla><code>OverlayWidgetController</code>，用于进入游戏时，主界面<hanla></hanla><code>Health</code><hanla></hanla>和<hanla></hanla><code>Mana</code><hanla></hanla>的更新</p>
</li>
<li><p>现在要添加<hanla></hanla><code>AttributeMenuWidget</code>，自然要同步添加<hanla></hanla><code>AttributeMenuWidgetController</code></p>
</li>
<li><p>所以在 HUD 类里，我们就要创建一个承载该实例的变量，并添加一个获取方法</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UAttributeMenuWidgetController* <span class="title">GetAttributeMenuWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCParams)</span></span>;</span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TObjectPtr&lt;UAttributeMenuWidgetController&gt; AttributeMenuWidgetController;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;UAttributeMenuWidgetController&gt; AttributeMenuWidgetControllerClass;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UAttributeMenuWidgetController* <span class="title">AAuraHUD::GetAttributeMenuWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WcParams)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 保证只实例化一次，后续<hanla></hanla>Get<hanla></hanla>的时候复用即可</span></span><br><span class="line">    <span class="keyword">if</span>(AttributeMenuWidgetController == <span class="literal">nullptr</span>)</span><br><span class="line">    {</span><br><span class="line">       AttributeMenuWidgetController = <span class="built_in">NewObject</span>&lt;UAttributeMenuWidgetController&gt;(<span class="keyword">this</span>, AttributeMenuWidgetControllerClass);</span><br><span class="line">       AttributeMenuWidgetController-&gt;<span class="built_in">SetWidgetControllerParams</span>(WcParams);</span><br><span class="line">       AttributeMenuWidgetController-&gt;<span class="built_in">BindCallbacksToDependencies</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> AttributeMenuWidgetController;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><p>创建一个基于<hanla></hanla><code>AttributeMenuWidgetController</code><hanla></hanla>的蓝图，让我们通过蓝图去设置<hanla></hanla><code>AttributeInfor</code><hanla></hanla>的数据</p>
<ol>
<li>将我们之前创建的 DataAsset 属性数据挂上去</li>
<li>在 HUD 蓝图上配置好<hanla></hanla><code>AttributeMenuWidgetControllerClass</code></li>
</ol>
</li>
<li><p>此时，在 HUD 初始化时，<code>OverlayWidgetControllerClass</code>（之前配置好的）和<hanla></hanla><code>AttributeMenuWidgetControllerClass</code><hanla></hanla>就都会被创建出来使用，接下来就是考虑如何在 UI 里去获得<hanla></hanla><code>WidgetController</code>，我们之前获取<hanla></hanla><code>OverlayWidgetController</code><hanla></hanla>是在创建 UI 的时候，在 Widget 事件里通过蓝图设置过去的，但是在属性面板里，层级太多，所以我们需要一个新的方式，能够在全局蓝图里获取<hanla></hanla><code>WidgetController</code></p>
</li>
<li><h5 id="创建-BlueprintFunctionLibrary"><a href="#创建-BlueprintFunctionLibrary" class="headerlink" title="创建 BlueprintFunctionLibrary"></a>创建 BlueprintFunctionLibrary</h5><ol>
<li><p>新建一个 C++<hanla></hanla>类继承自<hanla></hanla><code>BlueprintFunctionLibrary</code></p>
</li>
<li><p>创建两个静态函数，分别获取<hanla></hanla><code>OverlayWidgetController</code><hanla></hanla>和<hanla></hanla><code>AttributeMenuWidgetController</code>，使用<hanla></hanla><code>BlueprintPure</code><hanla></hanla>标记，这样我们可以直接拿到返回的结果</p>
<ol>
<li><p>A <code>BlueprintPure</code> function is shown as a node with no execution pin. By default functions marked <code>const</code> will be exposed as pure functions. To make a const function not a pure function, use <code>BlueprintPure=false</code>.</p>
<p>Pure functions do not cache their results, so be careful when doing any non-trivial amount of work a blueprint pure function. It is good practice to avoid outputting array properties in blueprint pure functions.</p>
<p><em>The function does not affect the owning object in any way and can be executed in a Blueprint or Level Blueprint graph.</em></p>
<p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/">Unreal Documentation</a></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AURA_API</span> UAuraAbilitySystemLibrary : <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">"AuraAbilitySystemLibrary|WidgetController"</span>)</span><br><span class="line">    <span class="function"><span class="type">static</span> UOverlayWidgetController* <span class="title">GetOverlayWidgetController</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">"AuraAbilitySystemLibrary|WidgetController"</span>)</span><br><span class="line">    <span class="function"><span class="type">static</span> UAttributeMenuWidgetController* <span class="title">GetAttributeMenuWidgetController</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>​<br>先从世界上下文对象中获取到本地的<hanla></hanla><code>PlayerController</code>，然后根据<hanla></hanla><code>PlayerController</code><hanla></hanla>获取到所需的配置项，再从<hanla></hanla>HUD<hanla></hanla>身上的函数获取<hanla></hanla><code>WidgetController</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UOverlayWidgetController* <span class="title">UAuraAbilitySystemLibrary::GetOverlayWidgetController</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 获取到<hanla></hanla>PlayerController，需要传入一个世界空间上下文的对象，用于得到对应世界中的<hanla></hanla>PC<hanla></hanla>列表，0<hanla></hanla>就代表本地使用的<hanla></hanla>PC</span></span><br><span class="line">    <span class="keyword">if</span> (APlayerController* PC = UGameplayStatics::<span class="built_in">GetPlayerController</span>(WorldContextObject, <span class="number">0</span>))</span><br><span class="line">    {</span><br><span class="line">       <span class="comment">// 从<hanla></hanla>PlayerController，我们就能获取到<hanla></hanla>HUD</span></span><br><span class="line">       <span class="keyword">if</span> (AAuraHUD* AuraHUD = <span class="built_in">Cast</span>&lt;AAuraHUD&gt;(PC-&gt;<span class="built_in">GetHUD</span>()))</span><br><span class="line">       {</span><br><span class="line">          AAuraPlayerState* PS = PC-&gt;<span class="built_in">GetPlayerState</span>&lt;AAuraPlayerState&gt;();</span><br><span class="line">          UAbilitySystemComponent* ASC = PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">          UAttributeSet* AS = PS-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line">          <span class="function"><span class="type">const</span> FWidgetControllerParams <span class="title">WidgetControllerParams</span><span class="params">(PC, PS, ASC, AS)</span></span>;</span><br><span class="line">          <span class="keyword">return</span> AuraHUD-&gt;<span class="built_in">GetOverlayWidgetController</span>(WidgetControllerParams);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the player controller found while iterating through the local and available remote player controllers.</span></span><br><span class="line"><span class="comment"> * On a network client, this will only include local players as remote player controllers are not available.</span></span><br><span class="line"><span class="comment"> * The index will be consistent as long as no new players join or leave, but it will not be the same across different clients and servers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param PlayerIndex   Index in the player controller list, starting first with local players and then available remote ones</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">"Game"</span>, meta=(WorldContext=<span class="string">"WorldContextObject"</span>, UnsafeDuringActorConstruction=<span class="string">"true"</span>))</span><br><span class="line"><span class="function"><span class="type">static</span> ENGINE_API <span class="keyword">class</span> APlayerController* <span class="title">GetPlayerController</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject, int32 PlayerIndex)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p>这时候，我们就能在任意蓝图里调用<hanla></hanla><code>GetOverlayWidgetController</code><hanla></hanla>和<hanla></hanla><code>GetAttributeMenuWidgetController</code></p>
<img src="/2024/11/14/GAS_UI/5.png" class="" title="img">

<blockquote>
<p>补充一点，我们在设置<hanla></hanla><code>OverlayWidgetController</code><hanla></hanla>的时候，是在 C++<hanla></hanla>里初始化 UI 属性时显示的</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraHUD::InitOverlay</span><span class="params">(APlayerController* PC, APlayerState* Ps, UAbilitySystemComponent* ASC, UAttributeSet* AS)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">checkf</span>(OverlayWidgetClass, <span class="built_in">TEXT</span>(<span class="string">"Overlay Widget Class uninitialized, pleased fill out BP_AuraHUD"</span>));</span><br><span class="line">    <span class="built_in">checkf</span>(OverlayWidgetControllerClass, <span class="built_in">TEXT</span>(<span class="string">"Overlay Widget Controller Class uninitialized, pleased fill out BP_AuraHUD"</span>));</span><br><span class="line"></span><br><span class="line">    UUserWidget* Widget =  <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), OverlayWidgetClass);</span><br><span class="line">    OverlayWidget = <span class="built_in">Cast</span>&lt;UAuraUserWidget&gt;(Widget);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> FWidgetControllerParams <span class="title">WidgetControllerParams</span><span class="params">(PC, Ps, ASC, AS)</span></span>;</span><br><span class="line">    UOverlayWidgetController* WidgetController = <span class="built_in">GetOverlayWidgetController</span>(WidgetControllerParams);</span><br><span class="line"></span><br><span class="line">    OverlayWidget-&gt;<span class="built_in">SetWidgetController</span>(WidgetController);</span><br><span class="line">    WidgetController-&gt;<span class="built_in">BroadcastInitialValues</span>();</span><br><span class="line">    Widget-&gt;<span class="built_in">AddToViewport</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAuraUserWidget::SetWidgetController</span><span class="params">(UObject* InWidgetController)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WidgetController = InWidgetController;</span><br><span class="line">    <span class="built_in">WidgetControllerSet</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><hanla></hanla>这里，我们先<hanla></hanla><code>OverlayWidget-&gt;SetWidgetController(WidgetController);</code>设置对应的<hanla></hanla><code>WidgetController</code>，然后再调用<hanla></hanla><code>WidgetControllerSet();</code>函数，这个函数在 UI 里设置各种事件</p>
<img src="/2024/11/14/GAS_UI/6.png" class="" title="img">

<img src="/2024/11/14/GAS_UI/7.png" class="" title="img">

<p>然后设置<hanla></hanla><code>AttributeMenuController</code>，则是在点击按钮，<code>AttributeMenu</code><hanla></hanla>菜单初始化，<code>construct</code><hanla></hanla>的时候使用<hanla></hanla><code>SetWidgetController</code><hanla></hanla>设置的（见下图）</p>
</blockquote>
</li>
<li><h5 id="广播数据，修改-UI"><a href="#广播数据，修改-UI" class="headerlink" title="广播数据，修改 UI"></a>广播数据，修改 UI</h5><ol>
<li><p>打开 AttributeMenu 菜单时，会做一个 Event Constuct 操作</p>
<p>​<img src="/2024/11/14/GAS_UI/8.png" class="" title="img"></p>
</li>
<li><p>在最后一步，有<hanla></hanla><code>Broadcast Initial Values</code><hanla></hanla>操作来广播所有的数据，首先通过 tag 去获取对应的 Attribute 属性，例如 StrengthTag 就获得 StrengthAttribute 之类的，对应的 Attribute 属性其实就是我们在<hanla></hanla><code>AuraAttributeSet</code><hanla></hanla>里定义的</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category = <span class="string">"Primary Attributes"</span>)</span><br><span class="line">FGameplayAttributeData Strength;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UAuraAttributeSet, Strength);</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们就能够得到 Attribute 的值，并且广播出去</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 如何获取我们想要的<hanla></hanla>AuraAttributeSet? 我们本身定义了一个<hanla></hanla>AttributeSet<hanla></hanla>变量<hanla></hanla>(父类<hanla></hanla>AuraWidgetController<hanla></hanla>里定义，在设置<hanla></hanla>Controller<hanla></hanla>的时候应该传入了对应的基础<hanla></hanla>AttributeSet)，直接<hanla></hanla>Cast</span></span><br><span class="line">    UAuraAttributeSet* AS = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    <span class="built_in">check</span>(AttributeInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : AS-&gt;TagsToAttributes)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">BroadcastAttributeInfo</span>(Pair.Key, Pair.<span class="built_in">Value</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastAttributeInfo</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FGameplayAttribute&amp; Attribute)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 通过<hanla></hanla>tag<hanla></hanla>找到<hanla></hanla>attributeinfo<hanla></hanla>这个<hanla></hanla>DataAsset<hanla></hanla>里存储的属性数据</span></span><br><span class="line">    FAuraAttributeInfo Info = AttributeInfo-&gt;<span class="built_in">FindAttributeInfoForTag</span>(AttributeTag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        别忘了，FGameplayAttribute<hanla></hanla>是用来描述<hanla></hanla>FGameplayAttributeData<hanla></hanla>的，Data<hanla></hanla>里面就包含属性的各种数据，如基础值、当前值、最大值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Returns the current value of an attribute</span></span><br><span class="line"><span class="comment">        float GetNumericValue(const UAttributeSet* Src) const;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Info.AttributeValue = Attribute.<span class="built_in">GetNumericValue</span>(AttributeSet);</span><br><span class="line">    AttributeInfoDelegate.<span class="built_in">Broadcast</span>(Info);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    UAuraAttributeSet* AS = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    <span class="built_in">check</span>(AttributeInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : AS-&gt;TagsToAttributes)</span><br><span class="line">    {</span><br><span class="line">       <span class="comment">// Whatever we bind to this delegate needs the correct signature, the signature we need have to take a const reference to FOnAttributeChangeData</span></span><br><span class="line">       AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Pair.<span class="built_in">Value</span>()).<span class="built_in">AddLambda</span>(</span><br><span class="line">          [<span class="keyword">this</span>, Pair](<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span><br><span class="line">          {</span><br><span class="line">             <span class="built_in">BroadcastAttributeInfo</span>(Pair.Key, Pair.<span class="built_in">Value</span>());</span><br><span class="line">          }</span><br><span class="line">       );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// UAttributeSet<hanla></hanla>示例<hanla></hanla></span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category = <span class="string">"Primary Attributes"</span>)</span><br><span class="line">FGameplayAttributeData Strength;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UAuraAttributeSet, Strength);</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>这里其实还有一个旧版</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastInitialValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 如何获取我们想要的<hanla></hanla>AuraAttributeSet? 我们本身定义了一个<hanla></hanla>AttributeSet<hanla></hanla>变量<hanla></hanla>(父类<hanla></hanla>AuraWidgetController<hanla></hanla>里定义，在设置<hanla></hanla>Controller<hanla></hanla>的时候应该传入了对应的基础<hanla></hanla>AttributeSet)，直接<hanla></hanla>Cast</span></span><br><span class="line">    UAuraAttributeSet* AS = <span class="built_in">CastChecked</span>&lt;UAuraAttributeSet&gt;(AttributeSet);</span><br><span class="line">    <span class="built_in">check</span>(AttributeInfo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个<hanla></hanla>attribute<hanla></hanla>都用一个<hanla></hanla>FindAttributeInfoForTag<hanla></hanla>去查找</span></span><br><span class="line">    FAuraAtributeInfo StrengthInfo = AttributeInfo-&gt;<span class="built_in">FindAttributeInfoForTag</span>(FAuraGameplayTags::<span class="built_in">Get</span>().Attributes_Primarty_Strength);</span><br><span class="line">    <span class="comment">// Attribute<hanla></hanla>标记的特性，自动封装了<hanla></hanla>Get<hanla></hanla>操作</span></span><br><span class="line">    StrengthInfo.AttributeValue = AS-&gt;<span class="built_in">GetStrength</span>();</span><br><span class="line">    AttributeInfoDelegate.<span class="built_in">Broadcast</span>(StrengthInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个<hanla></hanla>Attribute<hanla></hanla>都需要设置对应的标签查找</span></span><br><span class="line">    FAuraAtributeInfo IntelligenceInfo = AttributeInfo-&gt;<span class="built_in">FindAttributeInfoForTag</span>(FAuraGameplayTags::<span class="built_in">Get</span>().Attributes_Primarty_Intelligence);</span><br><span class="line">    IntelligenceInfo.AttributeValue = AS-&gt;<span class="built_in">GetIntelligence</span>();</span><br><span class="line">    AttributeInfoDelegate.<span class="built_in">Broadcast</span>(IntelligenceInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>再补充说一下，TagsToAttributes 的实现</p>
<ol>
<li><p>首先，是为了解决旧版每次设置 Attribute 都需要手写对应的标签查找出现的</p>
</li>
<li><p>所以，我们会存储一个 map，传入 tags 就能找到对应的 Attribute</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++11<hanla></hanla>后，typedef<hanla></hanla>就改成<hanla></hanla>using<hanla></hanla>了，都是一个功能，为现有类型创建别名</span></span><br><span class="line"><span class="comment">    在这个例子中，using<hanla></hanla>创建一个别名<hanla></hanla>TStaticFuncPtr，它表示 TBaseStaticDelegateInstance 类模板的一个特定成员类型 FFuncPtr。</span></span><br><span class="line"><span class="comment">    实现效果就是：</span></span><br><span class="line"><span class="comment">       接受一个类型参数 T，并将其转换为 TBaseStaticDelegateInstance&lt;T, FDefaultDelegateUserPolicy&gt;::FFuncPtr 类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TBaseStaticDelegateInstance 是一个类模板，用于创建静态委托实例。它通常用于处理函数指针或成员函数指针。</span></span><br><span class="line"><span class="comment">    FDefaultDelegateUserPolicy 是一个策略类，用于定义委托的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> TStaticFuncPtr = <span class="keyword">typename</span> TBaseStaticDelegateInstance&lt;T, FDefaultDelegateUserPolicy&gt;::FFuncPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    StaticFuncPtr&lt;FGameplayAttribute()&gt; 表示一个返回 FGameplayAttribute 类型且没有输入参数的函数指针</span></span><br><span class="line"><span class="comment">    TagsToAttributes 是一个映射，将 FGameplayTag 映射到一个返回 FGameplayAttribute 的函数指针<hanla></hanla></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TMap&lt;FGameplayTag, TStaticFuncPtr&lt;<span class="built_in">FGameplayAttribute</span>()&gt;&gt; TagsToAttributes;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>这之后，我们再在 AttributeSet 初始化的时候，为 TagsToAttributes 添加对应的 map</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Primary Attributes */</span></span><br><span class="line"><span class="comment">// Associate Tags to Attributes</span></span><br><span class="line">TagsToAttributes.<span class="built_in">Add</span>(GameplayTags.Attributes_Primary_Strength, GetStrengthAttribute);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Secondary Attributes */</span></span><br><span class="line">TagsToAttributes.<span class="built_in">Add</span>(GameplayTags.Attributes_Secondary_Armor, GetArmorAttribute);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>然后，这种 TagsToAttribute 也有旧实现方式</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DECLARE_DELEGATE_RetVal<hanla></hanla>宏代表是一个带有返回值的委托</span></span><br><span class="line"><span class="comment">    FGameplayAttributes<hanla></hanla>是返回的类型</span></span><br><span class="line"><span class="comment">    FAttributeSignature<hanla></hanla>是委托的名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    该委托可以绑定一个不接收任何参数的函数，然后返回<hanla></hanla>FGameplayAttribute</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">DECLARE_DELEGATE_RetVal</span>(FGameplayAttribute, FAttributeSignature);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义<hanla></hanla>Map</span></span><br><span class="line">TMap&lt;FGameplayTag, FAttributeSignature&gt; TagsToAttributes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化时为<hanla></hanla>Map<hanla></hanla>添加值<hanla></hanla></span></span><br><span class="line">UAuraAttributeSet::<span class="built_in">UAuraAttributeSet</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> FAuraGameplayTags&amp; GameplayTags = FAuraGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UAuraAttributeSet::GetStrengthAttribute 是一个静态成员函数，因此使用 BindStatic</span></span><br><span class="line">    FAttributeSignature StrengthDelegate;</span><br><span class="line">    StrengthDelegate.<span class="built_in">BindStatic</span>(UAuraAttributeSet::GetStrengthAttribute);</span><br><span class="line">    TagsToAttributes.<span class="built_in">Add</span>(GameplayTags.Attributes_Primary_Strength, StrengthDelegate);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取<hanla></hanla>AttributeValue<hanla></hanla>的时候要用<hanla></hanla>Execute()，触发绑定的函数<hanla></hanla></span></span><br><span class="line">FGameplayAttribute Attribute = xxx.Value.<span class="built_in">Execute</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>UI 菜单上对应的位置绑定对应的标签，实现对于数据的监听</p>
<ol>
<li>这里的 AttributeTag 是我们自定义的变量，到时候在 WBP_Attribute 里去设置对应属性的 ta<img src="/2024/11/14/GAS_UI/9.png" class="" title="img"></li>
</ol>
</li>
<li><p>通过 Attribute tag 设置值</p>
<ol>
<li><p>了解显示的结构</p>
<ol>
<li><p>在 AttributeMenu 菜单，知道每行都是继承自 WBP_TextValueRow 的，后面带按钮的也是先继承自 WBP_TextValueButtonRow，再继承自 WBP_TextValueRow</p>
<img src="/2024/11/14/GAS_UI/10.png" class="" title="img"></li>
<li><p>设置对应的值</p>
<img src="/2024/11/14/GAS_UI/11.png" class="" title="img">
<img src="/2024/11/14/GAS_UI/12.png" class="" title="img">
<img src="/2024/11/14/GAS_UI/13.png" class="" title="img">
</li>
<li><p>展示一下完整的结构，了解上面的变量中 WBP_FrameValue 和 TextBlockLabel 都对应着什么，一个是对应数值框模版，一个是对应着前面的标题 Text</p>
<img src="/2024/11/14/GAS_UI/19.png" class="" title="img">

<img src="/2024/11/14/GAS_UI/20.png" class="" title="img"></li>
</ol>
</li>
<li><p>我们发现，每行的数值都是和标签绑定的，只要 Attribute Info 发出消息，没啊很难过都根据自己的标签去更新对应的内容，但是在哪里给每行设置其标签呢？</p>
<img src="/2024/11/14/GAS_UI/14.png" class="" title="img">
<img src="/2024/11/14/GAS_UI/15.png" class="" title="img">
<img src="/2024/11/14/GAS_UI/16.png" class="" title="img">
<p>这些 RowStrength 变量，就是对应的 UI</p>
<img src="/2024/11/14/GAS_UI/17.png" class="" title="img">
<img src="/2024/11/14/GAS_UI/18.png" class="" title="img"></li>
</ol>
</li>
</ol>
</li>
</ol>
</div></article><aside class="post-widget"><h4>目录<hanla></hanla></h4><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UI-%E8%AE%BE%E8%AE%A1"><span class="post-toc-number">1.</span> <span class="post-toc-text">UI 设计<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UI-%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A"><span class="post-toc-number">2.</span> <span class="post-toc-text">UI 属性绑定<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">实现思路<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%97%A7%E7%89%88%E9%85%8D%E7%BD%AE%E5%A7%94%E6%89%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">旧版配置委托的实现<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#GameplayAttribute"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">GameplayAttribute</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B0%E7%89%88%E9%85%8D%E7%BD%AE%E5%A7%94%E6%89%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">新版配置委托的实现<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">设计思路<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">数据流<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">具体实现<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E9%85%8D%E7%BD%AE-GameplayTags-%E5%8D%95%E4%BE%8B"><span class="post-toc-number">2.3.3.1.</span> <span class="post-toc-text">配置 GameplayTags 单例<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%B1%BB"><span class="post-toc-number">2.3.3.2.</span> <span class="post-toc-text">实现资源管理器类<hanla></hanla></span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8-UI-%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">存储 UI 所需要的数据<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-DataAsset-%E8%80%8C%E4%B8%8D%E6%98%AF-DataTable%EF%BC%9F"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">为什么使用 DataAsset 而不是 DataTable？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%85%8D%E7%BD%AE-DataAsset"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">配置 DataAsset</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%B0-UI-%E4%B8%8A"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">将数据同步到 UI 上<hanla></hanla></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%85%8D%E7%BD%AEAttributeMenuWidgetController"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">配置<hanla></hanla>AttributeMenuWidgetController</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%85%8D%E7%BD%AE-HUD-%E7%B1%BB"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">配置 HUD 类<hanla></hanla></span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA-BlueprintFunctionLibrary"><span class="post-toc-number">2.5.3.</span> <span class="post-toc-text">创建 BlueprintFunctionLibrary</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B9%BF%E6%92%AD%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BF%AE%E6%94%B9-UI"><span class="post-toc-number">2.5.4.</span> <span class="post-toc-text">广播数据，修改 UI</span></a></li></ol></li></ol></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><div class="footer-content"><div><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv">?</span>
PV
</span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">?</span>
UV</span></div>

Copyright ©
2024<span class="time-divide">-</span>2025
Damue.

Power by
<a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>
and
<a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.2.5">Theme Yuzu</a>.</div></div></footer>
<script>window.config = {
  url_root: '/',
  meta_path: 'meta.json',
};
</script>
<script src="/js/theme/back-to-top.js"></script>


<script src="/js/theme/clipboard.js"></script>


<script src="/js/theme/loading.js"></script>


<script src="/js/theme/navbar.js"></script>

<script src="/js/theme/search.js"></script>

<script src="/js/theme/toc.js"></script>
<script>window.onload = function () {
  for (const moduleName in Theme) {
    const module = Theme[moduleName];
    module.register();
  }
};</script></div><div class="search-modal" id="search-modal"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="搜索"><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">共<hanla></hanla><span id="search-count-num">0</span><hanla></hanla>条搜索结果。</div><div class="search-result" id="search-result"></div></div></div></div></body></html>